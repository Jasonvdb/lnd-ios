// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: walletrpc/walletkit.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Walletrpc_WitnessType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknownWitness // = 0

  ///
  ///A witness that allows us to spend the output of a commitment transaction
  ///after a relative lock-time lockout.
  case commitmentTimeLock // = 1

  ///
  ///A witness that allows us to spend a settled no-delay output immediately on a
  ///counterparty's commitment transaction.
  case commitmentNoDelay // = 2

  ///
  ///A witness that allows us to sweep the settled output of a malicious
  ///counterparty's who broadcasts a revoked commitment transaction.
  case commitmentRevoke // = 3

  ///
  ///A witness that allows us to sweep an HTLC which we offered to the remote
  ///party in the case that they broadcast a revoked commitment state.
  case htlcOfferedRevoke // = 4

  ///
  ///A witness that allows us to sweep an HTLC output sent to us in the case that
  ///the remote party broadcasts a revoked commitment state.
  case htlcAcceptedRevoke // = 5

  ///
  ///A witness that allows us to sweep an HTLC output that we extended to a
  ///party, but was never fulfilled.  This HTLC output isn't directly on the
  ///commitment transaction, but is the result of a confirmed second-level HTLC
  ///transaction. As a result, we can only spend this after a CSV delay.
  case htlcOfferedTimeoutSecondLevel // = 6

  ///
  ///A witness that allows us to sweep an HTLC output that was offered to us, and
  ///for which we have a payment preimage. This HTLC output isn't directly on our
  ///commitment transaction, but is the result of confirmed second-level HTLC
  ///transaction. As a result, we can only spend this after a CSV delay.
  case htlcAcceptedSuccessSecondLevel // = 7

  ///
  ///A witness that allows us to sweep an HTLC that we offered to the remote
  ///party which lies in the commitment transaction of the remote party. We can
  ///spend this output after the absolute CLTV timeout of the HTLC as passed.
  case htlcOfferedRemoteTimeout // = 8

  ///
  ///A witness that allows us to sweep an HTLC that was offered to us by the
  ///remote party. We use this witness in the case that the remote party goes to
  ///chain, and we know the pre-image to the HTLC. We can sweep this without any
  ///additional timeout.
  case htlcAcceptedRemoteSuccess // = 9

  ///
  ///A witness that allows us to sweep an HTLC from the remote party's commitment
  ///transaction in the case that the broadcast a revoked commitment, but then
  ///also immediately attempt to go to the second level to claim the HTLC.
  case htlcSecondLevelRevoke // = 10

  ///
  ///A witness type that allows us to spend a regular p2wkh output that's sent to
  ///an output which is under complete control of the backing wallet.
  case witnessKeyHash // = 11

  ///
  ///A witness type that allows us to sweep an output that sends to a nested P2SH
  ///script that pays to a key solely under our control.
  case nestedWitnessKeyHash // = 12

  ///
  ///A witness type that allows us to spend our anchor on the commitment
  ///transaction.
  case commitmentAnchor // = 13
  case UNRECOGNIZED(Int)

  init() {
    self = .unknownWitness
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownWitness
    case 1: self = .commitmentTimeLock
    case 2: self = .commitmentNoDelay
    case 3: self = .commitmentRevoke
    case 4: self = .htlcOfferedRevoke
    case 5: self = .htlcAcceptedRevoke
    case 6: self = .htlcOfferedTimeoutSecondLevel
    case 7: self = .htlcAcceptedSuccessSecondLevel
    case 8: self = .htlcOfferedRemoteTimeout
    case 9: self = .htlcAcceptedRemoteSuccess
    case 10: self = .htlcSecondLevelRevoke
    case 11: self = .witnessKeyHash
    case 12: self = .nestedWitnessKeyHash
    case 13: self = .commitmentAnchor
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknownWitness: return 0
    case .commitmentTimeLock: return 1
    case .commitmentNoDelay: return 2
    case .commitmentRevoke: return 3
    case .htlcOfferedRevoke: return 4
    case .htlcAcceptedRevoke: return 5
    case .htlcOfferedTimeoutSecondLevel: return 6
    case .htlcAcceptedSuccessSecondLevel: return 7
    case .htlcOfferedRemoteTimeout: return 8
    case .htlcAcceptedRemoteSuccess: return 9
    case .htlcSecondLevelRevoke: return 10
    case .witnessKeyHash: return 11
    case .nestedWitnessKeyHash: return 12
    case .commitmentAnchor: return 13
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Walletrpc_WitnessType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Walletrpc_WitnessType] = [
    .unknownWitness,
    .commitmentTimeLock,
    .commitmentNoDelay,
    .commitmentRevoke,
    .htlcOfferedRevoke,
    .htlcAcceptedRevoke,
    .htlcOfferedTimeoutSecondLevel,
    .htlcAcceptedSuccessSecondLevel,
    .htlcOfferedRemoteTimeout,
    .htlcAcceptedRemoteSuccess,
    .htlcSecondLevelRevoke,
    .witnessKeyHash,
    .nestedWitnessKeyHash,
    .commitmentAnchor,
  ]
}

#endif  // swift(>=4.2)

struct Walletrpc_ListUnspentRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The minimum number of confirmations to be included.
  var minConfs: Int32 = 0

  /// The maximum number of confirmations to be included.
  var maxConfs: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_ListUnspentResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A list of utxos satisfying the specified number of confirmations.
  var utxos: [Lnrpc_Utxo] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_LeaseOutputRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///An ID of 32 random bytes that must be unique for each distinct application
  ///using this RPC which will be used to bound the output lease to.
  var id: Data = SwiftProtobuf.Internal.emptyData

  /// The identifying outpoint of the output being leased.
  var outpoint: Lnrpc_OutPoint {
    get {return _outpoint ?? Lnrpc_OutPoint()}
    set {_outpoint = newValue}
  }
  /// Returns true if `outpoint` has been explicitly set.
  var hasOutpoint: Bool {return self._outpoint != nil}
  /// Clears the value of `outpoint`. Subsequent reads from it will return its default value.
  mutating func clearOutpoint() {self._outpoint = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _outpoint: Lnrpc_OutPoint? = nil
}

struct Walletrpc_LeaseOutputResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The absolute expiration of the output lease represented as a unix timestamp.
  var expiration: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_ReleaseOutputRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The unique ID that was used to lock the output.
  var id: Data = SwiftProtobuf.Internal.emptyData

  /// The identifying outpoint of the output being released.
  var outpoint: Lnrpc_OutPoint {
    get {return _outpoint ?? Lnrpc_OutPoint()}
    set {_outpoint = newValue}
  }
  /// Returns true if `outpoint` has been explicitly set.
  var hasOutpoint: Bool {return self._outpoint != nil}
  /// Clears the value of `outpoint`. Subsequent reads from it will return its default value.
  mutating func clearOutpoint() {self._outpoint = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _outpoint: Lnrpc_OutPoint? = nil
}

struct Walletrpc_ReleaseOutputResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_KeyReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///Is the key finger print of the root pubkey that this request is targeting.
  ///This allows the WalletKit to possibly serve out keys for multiple HD chains
  ///via public derivation.
  var keyFingerPrint: Int32 = 0

  ///
  ///The target key family to derive a key from. In other contexts, this is
  ///known as the "account".
  var keyFamily: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// No fields, as we always give out a p2wkh address.
struct Walletrpc_AddrRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_AddrResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The address encoded using a bech32 format.
  var addr: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_Transaction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The raw serialized transaction.
  var txHex: Data = SwiftProtobuf.Internal.emptyData

  ///
  ///An optional label to save with the transaction. Limited to 500 characters.
  var label: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_PublishResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///If blank, then no error occurred and the transaction was successfully
  ///published. If not the empty string, then a string representation of the
  ///broadcast error.
  ///
  ///TODO(roasbeef): map to a proper enum type
  var publishError: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_SendOutputsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The number of satoshis per kilo weight that should be used when crafting
  ///this transaction.
  var satPerKw: Int64 = 0

  ///
  ///A slice of the outputs that should be created in the transaction produced.
  var outputs: [Signrpc_TxOut] = []

  /// An optional label for the transaction, limited to 500 characters.
  var label: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_SendOutputsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The serialized transaction sent out on the network.
  var rawTx: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_EstimateFeeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The number of confirmations to shoot for when estimating the fee.
  var confTarget: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_EstimateFeeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The amount of satoshis per kw that should be used in order to reach the
  ///confirmation target in the request.
  var satPerKw: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_PendingSweep {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The outpoint of the output we're attempting to sweep.
  var outpoint: Lnrpc_OutPoint {
    get {return _outpoint ?? Lnrpc_OutPoint()}
    set {_outpoint = newValue}
  }
  /// Returns true if `outpoint` has been explicitly set.
  var hasOutpoint: Bool {return self._outpoint != nil}
  /// Clears the value of `outpoint`. Subsequent reads from it will return its default value.
  mutating func clearOutpoint() {self._outpoint = nil}

  /// The witness type of the output we're attempting to sweep.
  var witnessType: Walletrpc_WitnessType = .unknownWitness

  /// The value of the output we're attempting to sweep.
  var amountSat: UInt32 = 0

  ///
  ///The fee rate we'll use to sweep the output. The fee rate is only determined
  ///once a sweeping transaction for the output is created, so it's possible for
  ///this to be 0 before this.
  var satPerByte: UInt32 = 0

  /// The number of broadcast attempts we've made to sweep the output.
  var broadcastAttempts: UInt32 = 0

  ///
  ///The next height of the chain at which we'll attempt to broadcast the
  ///sweep transaction of the output.
  var nextBroadcastHeight: UInt32 = 0

  /// The requested confirmation target for this output.
  var requestedConfTarget: UInt32 = 0

  /// The requested fee rate, expressed in sat/byte, for this output.
  var requestedSatPerByte: UInt32 = 0

  ///
  ///Whether this input must be force-swept. This means that it is swept even
  ///if it has a negative yield.
  var force: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _outpoint: Lnrpc_OutPoint? = nil
}

struct Walletrpc_PendingSweepsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_PendingSweepsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The set of outputs currently being swept by lnd's central batching engine.
  var pendingSweeps: [Walletrpc_PendingSweep] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_BumpFeeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The input we're attempting to bump the fee of.
  var outpoint: Lnrpc_OutPoint {
    get {return _outpoint ?? Lnrpc_OutPoint()}
    set {_outpoint = newValue}
  }
  /// Returns true if `outpoint` has been explicitly set.
  var hasOutpoint: Bool {return self._outpoint != nil}
  /// Clears the value of `outpoint`. Subsequent reads from it will return its default value.
  mutating func clearOutpoint() {self._outpoint = nil}

  /// The target number of blocks that the input should be spent within.
  var targetConf: UInt32 = 0

  ///
  ///The fee rate, expressed in sat/byte, that should be used to spend the input
  ///with.
  var satPerByte: UInt32 = 0

  ///
  ///Whether this input must be force-swept. This means that it is swept even
  ///if it has a negative yield.
  var force: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _outpoint: Lnrpc_OutPoint? = nil
}

struct Walletrpc_BumpFeeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_ListSweepsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///Retrieve the full sweep transaction details. If false, only the sweep txids
  ///will be returned.
  var verbose: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_ListSweepsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sweeps: Walletrpc_ListSweepsResponse.OneOf_Sweeps? = nil

  var transactionDetails: Lnrpc_TransactionDetails {
    get {
      if case .transactionDetails(let v)? = sweeps {return v}
      return Lnrpc_TransactionDetails()
    }
    set {sweeps = .transactionDetails(newValue)}
  }

  var transactionIds: Walletrpc_ListSweepsResponse.TransactionIDs {
    get {
      if case .transactionIds(let v)? = sweeps {return v}
      return Walletrpc_ListSweepsResponse.TransactionIDs()
    }
    set {sweeps = .transactionIds(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Sweeps: Equatable {
    case transactionDetails(Lnrpc_TransactionDetails)
    case transactionIds(Walletrpc_ListSweepsResponse.TransactionIDs)

  #if !swift(>=4.1)
    static func ==(lhs: Walletrpc_ListSweepsResponse.OneOf_Sweeps, rhs: Walletrpc_ListSweepsResponse.OneOf_Sweeps) -> Bool {
      switch (lhs, rhs) {
      case (.transactionDetails(let l), .transactionDetails(let r)): return l == r
      case (.transactionIds(let l), .transactionIds(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  struct TransactionIDs {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///
    ///Reversed, hex-encoded string representing the transaction ids of the
    ///sweeps that our node has broadcast. Note that these transactions may
    ///not have confirmed yet, we record sweeps on broadcast, not confirmation.
    var transactionIds: [String] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct Walletrpc_LabelTransactionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The txid of the transaction to label.
  var txid: Data = SwiftProtobuf.Internal.emptyData

  /// The label to add to the transaction, limited to 500 characters.
  var label: String = String()

  /// Whether to overwrite the existing label, if it is present.
  var overwrite: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_LabelTransactionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "walletrpc"

extension Walletrpc_WitnessType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_WITNESS"),
    1: .same(proto: "COMMITMENT_TIME_LOCK"),
    2: .same(proto: "COMMITMENT_NO_DELAY"),
    3: .same(proto: "COMMITMENT_REVOKE"),
    4: .same(proto: "HTLC_OFFERED_REVOKE"),
    5: .same(proto: "HTLC_ACCEPTED_REVOKE"),
    6: .same(proto: "HTLC_OFFERED_TIMEOUT_SECOND_LEVEL"),
    7: .same(proto: "HTLC_ACCEPTED_SUCCESS_SECOND_LEVEL"),
    8: .same(proto: "HTLC_OFFERED_REMOTE_TIMEOUT"),
    9: .same(proto: "HTLC_ACCEPTED_REMOTE_SUCCESS"),
    10: .same(proto: "HTLC_SECOND_LEVEL_REVOKE"),
    11: .same(proto: "WITNESS_KEY_HASH"),
    12: .same(proto: "NESTED_WITNESS_KEY_HASH"),
    13: .same(proto: "COMMITMENT_ANCHOR"),
  ]
}

extension Walletrpc_ListUnspentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListUnspentRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "min_confs"),
    2: .standard(proto: "max_confs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.minConfs)
      case 2: try decoder.decodeSingularInt32Field(value: &self.maxConfs)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.minConfs != 0 {
      try visitor.visitSingularInt32Field(value: self.minConfs, fieldNumber: 1)
    }
    if self.maxConfs != 0 {
      try visitor.visitSingularInt32Field(value: self.maxConfs, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_ListUnspentRequest, rhs: Walletrpc_ListUnspentRequest) -> Bool {
    if lhs.minConfs != rhs.minConfs {return false}
    if lhs.maxConfs != rhs.maxConfs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_ListUnspentResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListUnspentResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "utxos"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.utxos)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.utxos.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.utxos, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_ListUnspentResponse, rhs: Walletrpc_ListUnspentResponse) -> Bool {
    if lhs.utxos != rhs.utxos {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_LeaseOutputRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LeaseOutputRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "outpoint"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.id)
      case 2: try decoder.decodeSingularMessageField(value: &self._outpoint)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularBytesField(value: self.id, fieldNumber: 1)
    }
    if let v = self._outpoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_LeaseOutputRequest, rhs: Walletrpc_LeaseOutputRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._outpoint != rhs._outpoint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_LeaseOutputResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LeaseOutputResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "expiration"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self.expiration)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.expiration != 0 {
      try visitor.visitSingularUInt64Field(value: self.expiration, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_LeaseOutputResponse, rhs: Walletrpc_LeaseOutputResponse) -> Bool {
    if lhs.expiration != rhs.expiration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_ReleaseOutputRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReleaseOutputRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "outpoint"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.id)
      case 2: try decoder.decodeSingularMessageField(value: &self._outpoint)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularBytesField(value: self.id, fieldNumber: 1)
    }
    if let v = self._outpoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_ReleaseOutputRequest, rhs: Walletrpc_ReleaseOutputRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._outpoint != rhs._outpoint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_ReleaseOutputResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReleaseOutputResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_ReleaseOutputResponse, rhs: Walletrpc_ReleaseOutputResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_KeyReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".KeyReq"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "key_finger_print"),
    2: .standard(proto: "key_family"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.keyFingerPrint)
      case 2: try decoder.decodeSingularInt32Field(value: &self.keyFamily)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.keyFingerPrint != 0 {
      try visitor.visitSingularInt32Field(value: self.keyFingerPrint, fieldNumber: 1)
    }
    if self.keyFamily != 0 {
      try visitor.visitSingularInt32Field(value: self.keyFamily, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_KeyReq, rhs: Walletrpc_KeyReq) -> Bool {
    if lhs.keyFingerPrint != rhs.keyFingerPrint {return false}
    if lhs.keyFamily != rhs.keyFamily {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_AddrRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AddrRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_AddrRequest, rhs: Walletrpc_AddrRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_AddrResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AddrResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "addr"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.addr)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.addr.isEmpty {
      try visitor.visitSingularStringField(value: self.addr, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_AddrResponse, rhs: Walletrpc_AddrResponse) -> Bool {
    if lhs.addr != rhs.addr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_Transaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Transaction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tx_hex"),
    2: .same(proto: "label"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.txHex)
      case 2: try decoder.decodeSingularStringField(value: &self.label)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.txHex.isEmpty {
      try visitor.visitSingularBytesField(value: self.txHex, fieldNumber: 1)
    }
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_Transaction, rhs: Walletrpc_Transaction) -> Bool {
    if lhs.txHex != rhs.txHex {return false}
    if lhs.label != rhs.label {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_PublishResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PublishResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "publish_error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.publishError)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.publishError.isEmpty {
      try visitor.visitSingularStringField(value: self.publishError, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_PublishResponse, rhs: Walletrpc_PublishResponse) -> Bool {
    if lhs.publishError != rhs.publishError {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_SendOutputsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendOutputsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sat_per_kw"),
    2: .same(proto: "outputs"),
    3: .same(proto: "label"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.satPerKw)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.outputs)
      case 3: try decoder.decodeSingularStringField(value: &self.label)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.satPerKw != 0 {
      try visitor.visitSingularInt64Field(value: self.satPerKw, fieldNumber: 1)
    }
    if !self.outputs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.outputs, fieldNumber: 2)
    }
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_SendOutputsRequest, rhs: Walletrpc_SendOutputsRequest) -> Bool {
    if lhs.satPerKw != rhs.satPerKw {return false}
    if lhs.outputs != rhs.outputs {return false}
    if lhs.label != rhs.label {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_SendOutputsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendOutputsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "raw_tx"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.rawTx)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rawTx.isEmpty {
      try visitor.visitSingularBytesField(value: self.rawTx, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_SendOutputsResponse, rhs: Walletrpc_SendOutputsResponse) -> Bool {
    if lhs.rawTx != rhs.rawTx {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_EstimateFeeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EstimateFeeRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "conf_target"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.confTarget)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.confTarget != 0 {
      try visitor.visitSingularInt32Field(value: self.confTarget, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_EstimateFeeRequest, rhs: Walletrpc_EstimateFeeRequest) -> Bool {
    if lhs.confTarget != rhs.confTarget {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_EstimateFeeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EstimateFeeResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sat_per_kw"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.satPerKw)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.satPerKw != 0 {
      try visitor.visitSingularInt64Field(value: self.satPerKw, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_EstimateFeeResponse, rhs: Walletrpc_EstimateFeeResponse) -> Bool {
    if lhs.satPerKw != rhs.satPerKw {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_PendingSweep: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PendingSweep"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "outpoint"),
    2: .standard(proto: "witness_type"),
    3: .standard(proto: "amount_sat"),
    4: .standard(proto: "sat_per_byte"),
    5: .standard(proto: "broadcast_attempts"),
    6: .standard(proto: "next_broadcast_height"),
    8: .standard(proto: "requested_conf_target"),
    9: .standard(proto: "requested_sat_per_byte"),
    7: .same(proto: "force"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._outpoint)
      case 2: try decoder.decodeSingularEnumField(value: &self.witnessType)
      case 3: try decoder.decodeSingularUInt32Field(value: &self.amountSat)
      case 4: try decoder.decodeSingularUInt32Field(value: &self.satPerByte)
      case 5: try decoder.decodeSingularUInt32Field(value: &self.broadcastAttempts)
      case 6: try decoder.decodeSingularUInt32Field(value: &self.nextBroadcastHeight)
      case 7: try decoder.decodeSingularBoolField(value: &self.force)
      case 8: try decoder.decodeSingularUInt32Field(value: &self.requestedConfTarget)
      case 9: try decoder.decodeSingularUInt32Field(value: &self.requestedSatPerByte)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._outpoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.witnessType != .unknownWitness {
      try visitor.visitSingularEnumField(value: self.witnessType, fieldNumber: 2)
    }
    if self.amountSat != 0 {
      try visitor.visitSingularUInt32Field(value: self.amountSat, fieldNumber: 3)
    }
    if self.satPerByte != 0 {
      try visitor.visitSingularUInt32Field(value: self.satPerByte, fieldNumber: 4)
    }
    if self.broadcastAttempts != 0 {
      try visitor.visitSingularUInt32Field(value: self.broadcastAttempts, fieldNumber: 5)
    }
    if self.nextBroadcastHeight != 0 {
      try visitor.visitSingularUInt32Field(value: self.nextBroadcastHeight, fieldNumber: 6)
    }
    if self.force != false {
      try visitor.visitSingularBoolField(value: self.force, fieldNumber: 7)
    }
    if self.requestedConfTarget != 0 {
      try visitor.visitSingularUInt32Field(value: self.requestedConfTarget, fieldNumber: 8)
    }
    if self.requestedSatPerByte != 0 {
      try visitor.visitSingularUInt32Field(value: self.requestedSatPerByte, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_PendingSweep, rhs: Walletrpc_PendingSweep) -> Bool {
    if lhs._outpoint != rhs._outpoint {return false}
    if lhs.witnessType != rhs.witnessType {return false}
    if lhs.amountSat != rhs.amountSat {return false}
    if lhs.satPerByte != rhs.satPerByte {return false}
    if lhs.broadcastAttempts != rhs.broadcastAttempts {return false}
    if lhs.nextBroadcastHeight != rhs.nextBroadcastHeight {return false}
    if lhs.requestedConfTarget != rhs.requestedConfTarget {return false}
    if lhs.requestedSatPerByte != rhs.requestedSatPerByte {return false}
    if lhs.force != rhs.force {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_PendingSweepsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PendingSweepsRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_PendingSweepsRequest, rhs: Walletrpc_PendingSweepsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_PendingSweepsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PendingSweepsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pending_sweeps"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.pendingSweeps)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pendingSweeps.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pendingSweeps, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_PendingSweepsResponse, rhs: Walletrpc_PendingSweepsResponse) -> Bool {
    if lhs.pendingSweeps != rhs.pendingSweeps {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_BumpFeeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BumpFeeRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "outpoint"),
    2: .standard(proto: "target_conf"),
    3: .standard(proto: "sat_per_byte"),
    4: .same(proto: "force"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._outpoint)
      case 2: try decoder.decodeSingularUInt32Field(value: &self.targetConf)
      case 3: try decoder.decodeSingularUInt32Field(value: &self.satPerByte)
      case 4: try decoder.decodeSingularBoolField(value: &self.force)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._outpoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.targetConf != 0 {
      try visitor.visitSingularUInt32Field(value: self.targetConf, fieldNumber: 2)
    }
    if self.satPerByte != 0 {
      try visitor.visitSingularUInt32Field(value: self.satPerByte, fieldNumber: 3)
    }
    if self.force != false {
      try visitor.visitSingularBoolField(value: self.force, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_BumpFeeRequest, rhs: Walletrpc_BumpFeeRequest) -> Bool {
    if lhs._outpoint != rhs._outpoint {return false}
    if lhs.targetConf != rhs.targetConf {return false}
    if lhs.satPerByte != rhs.satPerByte {return false}
    if lhs.force != rhs.force {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_BumpFeeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BumpFeeResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_BumpFeeResponse, rhs: Walletrpc_BumpFeeResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_ListSweepsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListSweepsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "verbose"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.verbose)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.verbose != false {
      try visitor.visitSingularBoolField(value: self.verbose, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_ListSweepsRequest, rhs: Walletrpc_ListSweepsRequest) -> Bool {
    if lhs.verbose != rhs.verbose {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_ListSweepsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListSweepsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "transaction_details"),
    2: .standard(proto: "transaction_ids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1:
        var v: Lnrpc_TransactionDetails?
        if let current = self.sweeps {
          try decoder.handleConflictingOneOf()
          if case .transactionDetails(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.sweeps = .transactionDetails(v)}
      case 2:
        var v: Walletrpc_ListSweepsResponse.TransactionIDs?
        if let current = self.sweeps {
          try decoder.handleConflictingOneOf()
          if case .transactionIds(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.sweeps = .transactionIds(v)}
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    switch self.sweeps {
    case .transactionDetails(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    case .transactionIds(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_ListSweepsResponse, rhs: Walletrpc_ListSweepsResponse) -> Bool {
    if lhs.sweeps != rhs.sweeps {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_ListSweepsResponse.TransactionIDs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Walletrpc_ListSweepsResponse.protoMessageName + ".TransactionIDs"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "transaction_ids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.transactionIds)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.transactionIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.transactionIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_ListSweepsResponse.TransactionIDs, rhs: Walletrpc_ListSweepsResponse.TransactionIDs) -> Bool {
    if lhs.transactionIds != rhs.transactionIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_LabelTransactionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LabelTransactionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "txid"),
    2: .same(proto: "label"),
    3: .same(proto: "overwrite"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.txid)
      case 2: try decoder.decodeSingularStringField(value: &self.label)
      case 3: try decoder.decodeSingularBoolField(value: &self.overwrite)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.txid.isEmpty {
      try visitor.visitSingularBytesField(value: self.txid, fieldNumber: 1)
    }
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 2)
    }
    if self.overwrite != false {
      try visitor.visitSingularBoolField(value: self.overwrite, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_LabelTransactionRequest, rhs: Walletrpc_LabelTransactionRequest) -> Bool {
    if lhs.txid != rhs.txid {return false}
    if lhs.label != rhs.label {return false}
    if lhs.overwrite != rhs.overwrite {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_LabelTransactionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LabelTransactionResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_LabelTransactionResponse, rhs: Walletrpc_LabelTransactionResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
